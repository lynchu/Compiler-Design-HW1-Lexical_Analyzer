%option never-interactive
%option nounput
%option noinput

%{
/* C Declarations and Includes */
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#define MAX_LINE_LEN 512
/* Code runs each time a token is matched. */
#define YY_USER_ACTION updateCurrentLine(yytext);

uint32_t line_num = 1;
uint32_t col_num = 1;
static uint32_t opt_src = 1;
static uint32_t opt_tok = 1;
static char current_line[MAX_LINE_LEN];

static void updateCurrentLine(const char *source);
static void listToken(const char *name);
static void listLiteral(const char *name, const char *literal);
static bool isKeyword(const char *word);

%}

/* <Name>   <Regular Expression> */
delimiters  [,;:\[\]()]
operators   \+|\-|\*|\/|"mod"|:=|<|<=|<>|>=|>|=|"and"|"or"|"not"
digit       [0-9]
integer     0|[1-9]{digit}*
float       {integer}\.(0|{digit}*[1-9])
octal       0[0-7]+
real        ([1-9]{digit}*)|([1-9]{digit}*\.(0|{digit}*[1-9]))|(0\.{digit}*[1-9])
space       [ \t\n]+
letter      [a-zA-Z]
string      \"([^\"\n]|\"\")*\"

%x CCOMMENT 
%x CPPCOMMENT

%%
    /* <Regular Expression> <Action> */

"//&S-"(.*) { opt_src = 0; }
"//&T-"(.*) { opt_tok = 0; }
"//&S+"(.*) { opt_src = 1; }
"//&T+"(.*) { opt_tok = 1; }

"/*" { BEGIN(CCOMMENT); }
<CCOMMENT>[^*]*\*+([^/*][^*]*\*+)*"/" { BEGIN(INITIAL); }

"//" {BEGIN(CPPCOMMENT); }
<CPPCOMMENT>.* ;
<CPPCOMMENT>\n { BEGIN(INITIAL); }

{string} {
    char* tmp = malloc(yyleng); 
    strncpy(tmp, yytext+1, yyleng-2); 
    tmp[yyleng-2]='\0';

    if (opt_tok) {
        printf("<string: ");
    }

    for(int i=0;tmp[i]!='\0';i++) {
        if(tmp[i]=='"' && tmp[i+1]=='"'){
            if(opt_tok){
                printf("\"");
            }
            i++;
        } else {
            if(opt_tok){
                printf("%c", tmp[i]);
            }
        }
    }

    if(opt_tok){
        printf(">\n");
    }
}

{delimiters} {
    listToken(yytext);
}

{operators} {
    listToken(yytext);
}

{letter}({letter}|{digit})* {
    if(isKeyword(yytext)){
        char keyword[20];
        snprintf(keyword, sizeof(keyword), "KW%s", yytext);
        listToken(keyword);
    } else {
        listLiteral("id", yytext);
    }
}

{real}[eE][+-]?{integer} { listLiteral("scientific", yytext); }

{float} { listLiteral("float", yytext); }

{integer} { listLiteral("integer", yytext); }

{octal} { listLiteral("oct_integer", yytext); }

{space} ;


    /* Catch the character which is not accepted by rules above */
. {
    printf("Error at line %d: bad character \"%s\"\n", line_num, yytext);
    exit(-1);
}

%%
/* User Subroutine */

/** @note The line is printed out and flushed when a newline character is encountered. */
static void updateCurrentLine(const char *source) {
    /* col_num is one-based */
    for (const char *c = source; *c; ++c) {
        if (*c == '\n') {
            if (opt_src) {
                printf("%d: %s\n", line_num, current_line);
            }
            ++line_num;
            col_num = 1;
            current_line[0] = '\0';
        } else {
            if (col_num < MAX_LINE_LEN) {
                current_line[col_num - 1] = *c;
                current_line[col_num] = '\0';
            } else {
                /* Truncate silently; doesn't affect the program's correctness. */
            }
            ++col_num;
        }
    }
}

static void listToken(const char *name) {
    if (opt_tok) {
        printf("<%s>\n", name);
    }
}

static void listLiteral(const char *name, const char *literal) {
    if (opt_tok) {
        printf("<%s: %s>\n", name, literal);
    }
}

static bool isKeyword(const char *word) {
    const char *keywords[] = { "var", "def", 
                            "array", "of", "boolean", "integer", "real", "string", 
                            "true", "false", 
                            "while", "do", "if", "then", "else", "for", "to", 
                            "begin", "end", 
                            "print", "read", "return", NULL};

    for(int i = 0; keywords[i] != NULL; i++){
        if(strcmp(word, keywords[i])==0) return true;
    }
    return false;
}

/** @note This function is not required if the input file is guaranteed to end
 * with a newline. However, students may find it useful to handle the case where
 * the input file does not end with a newline, as it has been reported several
 * times in the past.
 */
int yywrap(void) {
    /* If the file is not ended with a newline, fake it to print out the last line. */
    if (col_num > 1) {
        updateCurrentLine("\n");
    }
    /* no more input file */
    return 1;
}

int main(int argc, const char **argv) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s [filename]\n", argv[0]);
        exit(-1);
    }

    yyin = fopen(argv[1], "r");
    if (yyin == NULL) {
        fprintf(stderr, "Open file error\n");
        exit(-1);
    }

    yylex();

    fclose(yyin);
    /* Free resources used by the scanner; otherwise, unused data structures
    will persist throughout the successive compiler phases. */
    yylex_destroy();

    return 0;
}
